name: Build and push Docker images

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io

jobs:
  parse:
    name: Parse docker-compose
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.set.outputs.services }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.x"

      - name: Install PyYAML
        run: python -m pip install pyyaml

      - name: Parse docker-compose.yml and emit matrix
        id: set
        run: |
          python - <<'PY'
          import yaml, json, os, sys

          compose_file = 'docker-compose.yml'
          if not os.path.exists(compose_file):
              print('[]')
              sys.exit(0)

          with open(compose_file, 'r') as f:
              doc = yaml.safe_load(f) or {}

          services = []
          for name, svc in (doc.get('services') or {}).items():
              b = svc.get('build')
              if not b:
                  # skip services that don't declare a build context
                  continue

              # Default values
              ctx = '.'
              dockerfile = 'Dockerfile'

              if isinstance(b, str):
                  ctx = b
                  dockerfile = os.path.join(ctx, 'Dockerfile')
              elif isinstance(b, dict):
                  ctx = b.get('context', '.')
                  dockerfile = b.get('dockerfile', 'Dockerfile')
                  # if dockerfile is a relative path, resolve relative to context
                  if not os.path.isabs(dockerfile):
                      dockerfile = os.path.normpath(os.path.join(ctx, dockerfile))
              else:
                  continue

              # Normalise and ensure no leading './' surprises
              ctx = os.path.normpath(ctx)
              dockerfile = os.path.normpath(dockerfile)

              services.append({
                  'name': name,
                  'context': ctx,
                  'dockerfile': dockerfile
              })

          out = json.dumps(services)
          # Emit as step output
          print(out)
          # write to GITHUB_OUTPUT for use in job outputs
          with open(os.environ.get('GITHUB_OUTPUT'), 'a') as g:
              g.write(f"services={out}\n")
          PY

  build-and-push:
    name: Build and push images
    needs: parse
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.parse.outputs.services) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          # platforms: linux/amd64,linux/arm64
          platforms: linux/amd64
          tags: |
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}-${{ matrix.service.name }}:latest
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}-${{ matrix.service.name }}:${{ github.sha }}

      - name: Print pushed image names
        run: |
          echo "Pushed images for service: ${{ matrix.service.name }}"
          echo "${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}-${{ matrix.service.name }}:latest"
          echo "${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}-${{ matrix.service.name }}:${{ github.sha }}"

      - name: Visibility / public note
        if: always()
        run: |
          echo "By default, container packages pushed to ghcr.io may be private. To make them public you must update package visibility."
          echo "You can use the GitHub API or gh CLI. Example using gh (requires a token with appropriate scopes):"
          echo ""
          echo "  # Organization package"
          echo "  gh api --method PATCH /orgs/ORG/packages/container/PACKAGE_NAME -f visibility=public"
          echo ""
          echo "  # User package"
          echo "  gh api --method PATCH /user/packages/container/PACKAGE_NAME -f visibility=public"
          echo ""
          echo "Replace ORG/USER and PACKAGE_NAME with the proper values (PACKAGE_NAME is typically the repository-and-service name used above)."
          echo "Note: The GITHUB_TOKEN provided to Actions may not have permissions to change package visibility; a personal access token or organization admin token may be required."
